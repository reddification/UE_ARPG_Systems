// Fill out your copyright notice in the Description page of Project Settings.


#include "EQS/Generators/EnvQueryGenerator_SimpleGridRelativeTo.h"

#include "Data/LogChannels.h"

#define LOCTEXT_NAMESPACE "EnvQueryGenerator"

void UEnvQueryGenerator_SimpleGridRelativeTo::GenerateItems(FEnvQueryInstance& QueryInstance) const
{
	UObject* BindOwner = QueryInstance.Owner.Get();
	GridSize.BindData(BindOwner, QueryInstance.QueryID);
	SpaceBetween.BindData(BindOwner, QueryInstance.QueryID);

	float RadiusValue = GridSize.GetValue();
	float DensityValue = SpaceBetween.GetValue();

	const int32 ItemCount = FPlatformMath::TruncToInt((RadiusValue * 2.0f / DensityValue) + 1);
	const int32 ItemCountHalf = ItemCount / 2;

	TArray<FVector> ContextLocations;
	TArray<FVector> RelativeToLocations;
	QueryInstance.PrepareContext(GenerateAround, ContextLocations);
	QueryInstance.PrepareContext(StartRelativeTo, RelativeToLocations);

	if (RelativeToLocations.Num() != 1)
	{
		UE_VLOG(BindOwner, LogARPGAI, Error, TEXT("UEnvQueryGenerator_SimpleGridRelativeTo::GenerateItems - no context items (or more than 1)"));
		return;
	}
	
	const FVector& RelativeToLocation = RelativeToLocations[0];
	TArray<FNavLocation> GridPoints;
	GridPoints.Reserve(ItemCount * ItemCount * ContextLocations.Num());


	// #YOLO this code is generated by chat gpt. 10 years on and programmers will not be able to even do dot products checks on their own	
	// Determine the number of grid points along the forward (depth) and side (width) directions.
	// The full depth/width of the rectangle is 2 * GridHalfSize.
	const int32 ForwardCount = FPlatformMath::TruncToInt((RadiusValue * 2.0f / DensityValue) + 1);
	const int32 SideCount = FPlatformMath::TruncToInt((RadiusValue * 2.0f / DensityValue) + 1);
	
	for (int32 ContextIndex = 0; ContextIndex < ContextLocations.Num(); ContextIndex++)
	{
		const FVector& ContextLocation = ContextLocations[ContextIndex];
		// Compute the forward (or “look”) direction from the context to the relative point.
		const FVector Forward = bInverseDirection
			? (ContextLocation - RelativeToLocation).GetSafeNormal()
			: (RelativeToLocation - ContextLocation).GetSafeNormal();
		// Compute a right vector perpendicular to Forward using the world up vector.
		const FVector Right = FVector::CrossProduct(FVector::UpVector, Forward).GetSafeNormal();

		// The context location is now assumed to be at the center of the front edge.
		// Grid points will be generated in a rectangle that extends forward from ContextLocation.
		for (int32 i = 0; i < ForwardCount; ++i)
		{
			// Distance along the forward direction (starting at 0 at the context location)
			float ForwardOffset = i * DensityValue;

			for (int32 j = 0; j < SideCount; ++j)
			{
				// Offset sideways such that the center of the edge is at zero.
				float SideOffset = (j - (SideCount - 1) / 2.0f) * DensityValue;

				// Calculate the grid point location.
				FVector TestLocation = ContextLocation + (Forward * ForwardOffset) + (Right * SideOffset);
				GridPoints.Add(FNavLocation(TestLocation));
			}
		}
	}

	ProjectAndFilterNavPoints(GridPoints, QueryInstance);
	StoreNavPoints(GridPoints, QueryInstance);
}

FText UEnvQueryGenerator_SimpleGridRelativeTo::GetDescriptionTitle() const
{
	return FText::Format(LOCTEXT("SimpleGridRelativeToDescriptionGenerateAroundContext", "{0}: generate from {1} in direction towards {2}"),
		Super::Super::GetDescriptionTitle(), UEnvQueryTypes::DescribeContext(GenerateAround), UEnvQueryTypes::DescribeContext(StartRelativeTo));
}

#undef LOCTEXT_NAMESPACE