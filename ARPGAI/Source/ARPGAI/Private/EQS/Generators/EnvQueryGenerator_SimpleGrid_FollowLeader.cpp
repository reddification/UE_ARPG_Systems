// Fill out your copyright notice in the Description page of Project Settings.


#include "EQS/Generators/EnvQueryGenerator_SimpleGrid_FollowLeader.h"

#include "Data/LogChannels.h"
#include "EQS/Contexts/EnvQueryContext_FollowTarget.h"
#include "EQS/Contexts/EnvQueryContext_FollowTargetPredictedLocation.h"

UEnvQueryGenerator_SimpleGrid_FollowLeader::UEnvQueryGenerator_SimpleGrid_FollowLeader()
{
	FollowTargetContext = UEnvQueryContext_FollowTarget::StaticClass();
	GenerateAround = UEnvQueryContext_FollowTargetPredictedLocation::StaticClass();
}

void UEnvQueryGenerator_SimpleGrid_FollowLeader::GenerateItems(FEnvQueryInstance& QueryInstance) const
{
	UObject* BindOwner = QueryInstance.Owner.Get();
	GridSize.BindData(BindOwner, QueryInstance.QueryID);
	SpaceBetween.BindData(BindOwner, QueryInstance.QueryID);

	float RadiusValue = GridSize.GetValue();
	float DensityValue = SpaceBetween.GetValue();

	const int32 ItemCount = FPlatformMath::TruncToInt((RadiusValue * 2.0f / DensityValue) + 1);

	TArray<FVector> ContextLocations;
	TArray<AActor*> FollowTargets;
	QueryInstance.PrepareContext(GenerateAround, ContextLocations);
	QueryInstance.PrepareContext(FollowTargetContext, FollowTargets);

	if (ContextLocations.Num() != 1)
	{
		UE_VLOG(BindOwner, LogARPGAI, Error, TEXT("UEnvQueryGenerator_SimpleGrid_FollowLeader::GenerateItems - no context items (or more than 1)"));
		return;
	}

	if (FollowTargets.Num() != 1)
	{
		UE_VLOG(BindOwner, LogARPGAI, Error, TEXT("UEnvQueryGenerator_SimpleGrid_FollowLeader::GenerateItems - no follow targets (or more than 1)"));
		return;
	}
	
	TArray<FNavLocation> GridPoints;
	GridPoints.Reserve(ItemCount * ItemCount * ContextLocations.Num());

	// #YOLO this code is generated by chat gpt. 10 years on and programmers will not be able to even do dot products checks on their own	
	// Determine the number of grid points along the forward (depth) and side (width) directions.
	// The full depth/width of the rectangle is 2 * GridHalfSize.
	const int32 ForwardCount = FPlatformMath::TruncToInt((RadiusValue * 2.0f / DensityValue) + 1);
	const int32 SideCount = FPlatformMath::TruncToInt((RadiusValue * 2.0f / DensityValue) + 1);
	
	const FVector& ContextLocation = ContextLocations[0];
	// Compute the forward (or “look”) direction from the context to the relative point.
	const FVector Forward = FollowTargets[0]->GetActorForwardVector();
	// Compute a right vector perpendicular to Forward using the world up vector.
	const FVector Right = FVector::CrossProduct(FVector::UpVector, Forward).GetSafeNormal();

	// The context location is now assumed to be at the center of the front edge.
	// Grid points will be generated in a rectangle that extends forward from ContextLocation.
	for (int32 i = -ForwardCount / 2; i < ForwardCount / 2; ++i)
	{
		// Distance along the forward direction (starting at 0 at the context location)
		const float ForwardOffset = i * DensityValue;

		for (int32 j = -SideCount / 2; j < SideCount / 2; ++j)
		{
			// Offset sideways such that the center of the edge is at zero.
			// float SideOffset = (j - (SideCount - 1) / 2.0f) * DensityValue;
			const float SideOffset = j * DensityValue;

			// Calculate the grid point location.
			FVector TestLocation = ContextLocation + (Forward * ForwardOffset) + (Right * SideOffset);
			GridPoints.Add(FNavLocation(TestLocation));
		}
	}
	
	ProjectAndFilterNavPoints(GridPoints, QueryInstance);
	StoreNavPoints(GridPoints, QueryInstance);
}

FText UEnvQueryGenerator_SimpleGrid_FollowLeader::GetDescriptionTitle() const
{
	return FText::FromString(FString::Printf(TEXT("Generate grid around %s oriented by %s"), *UEnvQueryTypes::DescribeContext(GenerateAround).ToString(),
		*UEnvQueryTypes::DescribeContext(FollowTargetContext).ToString()));
}
